from __future__ import print_function
import re
import time
from decimal import Decimal

from ...version import __version__


HEADER_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version ${ctx.version} ${ctx.date}.
 */

#ifndef ${ctx.include_guard}
#define ${ctx.include_guard}

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

/* Frame ids. */
% for message in ctx.messages:
#define ${message.struct_name.upper()}_FRAME_ID (0x${"%02x" % message.frame_id}u)
% endfor

/* Frame lengths in bytes. */
% for message in ctx.messages:
#define ${message.struct_name.upper()}_LENGTH (${message.length}u)
% endfor

/* Extended or standard frame types. */
% for message in ctx.messages:
#define ${message.struct_name.upper()}_IS_EXTENDED (${int(message.is_extended_frame)})
% endfor

/* Frame cycle times in milliseconds. */
% for message in ctx.messages:
% if message.cycle_time is not None:
#define ${message.struct_name.upper()}_CYCLE_TIME_MS (${message.cycle_time}u)
% endif
% endfor

/* Signal choices. */
% for message in ctx.messages:
% for signal in message.signals:
% if signal.choices is not None:
% for value, name in sorted(signal.unique_choices.items()):
% if signal.is_signed:
#define ${message.struct_name.upper()}_${signal.name.upper()}_${name}_CHOICE (${value})
% else:
#define ${message.struct_name.upper()}_${signal.name.upper()}_${name}_CHOICE (${value}u)
% endif
% endfor
% endif
% endfor
% endfor

% for message in ctx.messages:
/**
 * Signals in message ${message.name}.
 *
% if message.comment:
${ctx.indent_c_comment(message.comment)}
 *
% endif
 * All signal values are as on the CAN bus.
 */
struct ${message.struct_name}_t {
% for signal in message.signals:
    /**
% if signal.comment:
${ctx.indent_c_comment(signal.comment, 4)}
     *
% endif
     * Range: ${signal.range_str()}
     * Scale: ${signal.scale_str()}
     * Offset: ${signal.offset_str()}
     */
% if signal.is_float or not ctx.bit_fields:
    ${signal.type_name} ${signal.snake_name};
% else:
    ${signal.type_name} ${signal.snake_name} : ${signal.length};
% endif
% endfor
% if len(message.signals) == 0:
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
% endif
};

% endfor

% for message in ctx.messages:
/**
 * Pack message ${message.name}.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
int ${message.struct_name}_pack(
    uint8_t *dst_p,
    const struct ${message.struct_name}_t *src_p,
    size_t size);

/**
 * Unpack message ${message.name}.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
int ${message.struct_name}_unpack(
    struct ${message.struct_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size);

% for signal in message.signals:
% if ctx.floating_point_numbers:
/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
${signal.type_name} ${message.struct_name}_${signal.snake_name}_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
double ${message.struct_name}_${signal.snake_name}_decode(${signal.type_name} value);

% endif
/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
bool ${message.struct_name}_${signal.snake_name}_is_in_range(${signal.type_name} value);

% endfor

% endfor
#endif
'''

SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version ${ctx.version} ${ctx.date}.
 */

#include <string.h>

#include "${ctx.database_name}.h"

<%def name="emit_signal_helper(message, signal_name)">\\
<%
signal = message.get_signal_by_name(signal_name)
%>\\
% for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
% if (signal.type_length, shift_direction) not in seen_packer_helpers:
static inline uint8_t pack_${shift_direction}_shift_u${signal.type_length}(
    uint${signal.type_length}_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value ${'<<' if shift_direction=='left' else '>>'} shift) & mask);
}

<%
seen_packer_helpers.add((signal.type_length, shift_direction))
%>\\
% endif
% endfor
% for index, shift, shift_direction, mask in signal.segments(invert_shift=True):
% if (signal.type_length, shift_direction) not in seen_unpacker_helpers:
static inline uint${signal.type_length}_t unpack_${shift_direction}_shift_u${signal.type_length}(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint${signal.type_length}_t)((uint${signal.type_length}_t)(value & mask) ${'<<' if shift_direction=='left' else '>>'} shift);
}

<%
seen_unpacker_helpers.add((signal.type_length, shift_direction))
%>\\
% endif
% endfor
</%def>\\
<%def name="emit_signal_helpers(message, signal_names)">\\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
%>\\
${emit_signal_helper(message, signal_name)}\\
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
${emit_signal_helpers(message, multiplexed_signals)}\\
% endfor
% else: # if isinstance(signal_name, dict):
${emit_signal_helper(message, signal_name)}\\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\\
<%
seen_packer_helpers = set()
seen_unpacker_helpers = set()
%>\\
% for message in ctx.messages:
${emit_signal_helpers(message, message.signal_tree)}\\
% endfor
<%def name="emit_signal_pack_variables(seen_vars, message, signal_name)">\\
<%
signal = message.get_signal_by_name(signal_name)
%>\\
% if signal.is_float or signal.is_signed:
% if (signal.type_length, signal.snake_name) not in seen_vars:
    uint${signal.type_length}_t ${signal.snake_name};
<%
seen_vars.add((signal.type_length, signal.snake_name))
%>\\
% endif # if (${signal.type_length}, ${signal.snake_name}) not in seen_vars:
% endif # if signal.is_float or signal.is_signed:
</%def>\\
<%def name="emit_message_pack_variables(seen_vars, message, signal_names)">\\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
%>\\
${emit_signal_pack_variables(seen_vars, message, signal_name)}\\
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
${emit_message_pack_variables(seen_vars, message, multiplexed_signals)}\\
% endfor
% else: # if isinstance(signal_name, dict):
${emit_signal_pack_variables(seen_vars, message, signal_name)}\\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\\
<%def name="emit_signal_pack_body(message, signal_name, indent_level)">\\
<%
signal = message.get_signal_by_name(signal_name)
%>\\
% if signal.is_float:
${'    ' * indent_level}memcpy(&${signal.snake_name}, &src_p->${signal.snake_name}, sizeof(${signal.snake_name}));
% elif signal.is_signed:
${'    ' * indent_level}${signal.snake_name} = (uint${signal.type_length}_t)src_p->${signal.snake_name};
% endif # if signal.is_float:
% for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
% if signal.is_float or signal.is_signed:
${'    ' * indent_level}dst_p[${index}] |= pack_${shift_direction}_shift_u${signal.type_length}(${signal.snake_name}, ${shift}u, ${"0x%02x" % mask}u);
% else: # if signal.is_float or signal.is_signed:
${'    ' * indent_level}dst_p[${index}] |= pack_${shift_direction}_shift_u${signal.type_length}(src_p->${signal.snake_name}, ${shift}u, ${"0x%02x" % mask}u);
% endif # if signal.is_float or signal.is_signed:
% endfor
</%def>\\
<%def name="emit_message_pack_body(message, signal_names, indent_level=1)">\\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
signal = message.get_signal_by_name(signal_name)
%>\\
${emit_signal_pack_body(message, signal_name, indent_level)}\\

${'    ' * indent_level}switch (src_p->${signal.snake_name}) {
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:

${'    ' * indent_level}case ${multiplexer_id}:
${emit_message_pack_body(message, multiplexed_signals, indent_level+1)}\\
${'    ' * (indent_level+1)}break;
% endfor

${'    ' * indent_level}default:
${'    ' * (indent_level+1)}break;
${'    ' * indent_level}}
% else: # if isinstance(signal_name, dict):
${emit_signal_pack_body(message, signal_name, indent_level)}\\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\\
<%def name="emit_signal_unpack_body(message, signal_name, indent_level)">\\
<%
signal = message.get_signal_by_name(signal_name)
%>\\
% for i, (index, shift, shift_direction, mask) in enumerate(signal.segments(invert_shift=True)):
% if signal.is_float or signal.is_signed:
${'    ' * indent_level}${signal.snake_name} ${'=' if i==0 else '|='} unpack_${shift_direction}_shift_u${signal.type_length}(src_p[${index}], ${shift}u, ${"0x%02x" % mask}u);
% else:
${'    ' * indent_level}dst_p->${signal.snake_name} ${'=' if i==0 else '|='} unpack_${shift_direction}_shift_u${signal.type_length}(src_p[${index}], ${shift}u, ${"0x%02x" % mask}u);
% endif # signal.is_float or signal.is_signed:
% endfor
% if signal.is_float:
${'    ' * indent_level}memcpy(&dst_p->${signal.snake_name}, &${signal.snake_name}, sizeof(dst_p->${signal.snake_name}));
% elif signal.is_signed:
<%
mask = ((1 << (signal.type_length - signal.length)) - 1)
%>\\
% if mask != 0:

${'    ' * indent_level}if ((${signal.snake_name} & (1${signal.conversion_type_suffix} << ${signal.length - 1})) != 0${signal.conversion_type_suffix}) {
${'    ' * indent_level}    ${signal.snake_name} |= ${"0x%x" % (mask << signal.length)}${signal.conversion_type_suffix};
${'    ' * indent_level}}

% endif # mask != 0:
${'    ' * indent_level}dst_p->${signal.snake_name} = (int${signal.type_length}_t)${signal.snake_name};
% endif # signal.is_float:
</%def>\\
<%def name="emit_message_unpack_body(message, signal_names, indent_level=1)">\\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
signal = message.get_signal_by_name(signal_name)
%>\\
${emit_signal_unpack_body(message, signal_name, indent_level)}\\

${'    ' * indent_level}switch (dst_p->${signal.snake_name}) {
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:

${'    ' * indent_level}case ${multiplexer_id}:
${emit_message_unpack_body(message, multiplexed_signals, indent_level+1)}\\
${'    ' * (indent_level+1)}break;
% endfor

${'    ' * indent_level}default:
${'    ' * (indent_level+1)}break;
${'    ' * indent_level}}
% else: # if isinstance(signal_name, dict):
${emit_signal_unpack_body(message, signal_name, indent_level)}\\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\\
% for message in ctx.messages:
% if message.length > 0:
int ${message.struct_name}_pack(
    uint8_t *dst_p,
    const struct ${message.struct_name}_t *src_p,
    size_t size)
{
% if len(message.signals) == 0:
    (void)src_p;
% endif # if len(message.signals) == 0:
${emit_message_pack_variables(set(), message, message.signal_tree)}\\

    if (size < ${message.length}u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, ${message.length});

${emit_message_pack_body(message, message.signal_tree)}\\

    return (${message.length});
}

int ${message.struct_name}_unpack(
    struct ${message.struct_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
% if len(message.signals) == 0:
    (void)src_p;
% endif # if len(message.signals) == 0:
<%
seen_vars = set()
%>\\
${emit_message_pack_variables(seen_vars, message, message.signal_tree)}\\

    if (size < ${message.length}u) {
        return (-EINVAL);
    }

${emit_message_unpack_body(message, message.signal_tree)}\\

    return (0);
}
% else: # if message.length > 0:
int ${message.struct_name}_pack(
    uint8_t *dst_p,
    const struct ${message.struct_name}_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int ${message.struct_name}_unpack(
    struct ${message.struct_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;
    (void)size;

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}
% endif # if message.length > 0:

% for signal in message.signals:
<%
scale = signal.decimal.scale
offset = signal.decimal.offset
if offset == 0 and scale == 1:
    encoding = 'value'
    decoding = '(double)value'
elif offset != 0 and scale != 1:
    encoding = '(value - {}) / {}'.format(float(offset),
                                          float(scale))
    decoding = '((double)value * {}) + {}'.format(float(scale),
                                                  float(offset))
elif offset != 0:
    encoding = 'value - {}'.format(float(offset))
    decoding = '(double)value + {}'.format(float(offset))
else:
    encoding = 'value / {}'.format(float(scale))
    decoding = '(double)value * {}'.format(float(scale))
%>\\
% if ctx.floating_point_numbers:
${signal.type_name} ${message.struct_name}_${signal.snake_name}_encode(double value)
{
    return (${signal.type_name})(${encoding});
}

double ${message.struct_name}_${signal.snake_name}_decode(${signal.type_name} value)
{
    return (${decoding});
}

% endif # if ctx.floating_point_numbers:
bool ${message.struct_name}_${signal.snake_name}_is_in_range(${signal.type_name} value)
{
<%
scale = signal.decimal.scale
offset = (signal.decimal.offset / scale)
minimum = signal.decimal.minimum
maximum = signal.decimal.maximum

if minimum is not None:
    minimum = (minimum / scale - offset)

if maximum is not None:
    maximum = (maximum / scale - offset)

if minimum is None and signal.minimum_value is not None:
    if signal.minimum_value > signal.minimum_type_value:
        minimum = signal.minimum_value

if maximum is None and signal.maximum_value is not None:
    if signal.maximum_value < signal.maximum_type_value:
        maximum = signal.maximum_value

check = []

if minimum is not None:
    if (signal.minimum_type_value is None) or (minimum > signal.minimum_type_value):
        minimum = float(minimum) if signal.is_float else int(minimum)
        check.append('value >= {}{}'.format(minimum, signal.type_suffix))

if maximum is not None:
    if (signal.maximum_type_value is None) or (maximum < signal.maximum_type_value):
        maximum = float(maximum) if signal.is_float else int(maximum)
        check.append('value <= {}{}'.format(maximum, signal.type_suffix))
%>\\
% if len(check) == 0:
    (void)value;

    return (true);
% elif len(check) == 1:
    return (${check[0]});
% else:
    return (${' && '.join(['({})'.format(c) for c in check])});
% endif
}

% endfor
% endfor
'''

FUZZER_SOURCE_FMT = '''\
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version ${ctx.version} ${ctx.date}.
 */

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include <string.h>
#include <stdio.h>

#include "${ctx.database_name}.h"

static void assert_first_pack(int res)
{
    if (res < 0) {
        printf("First pack failed with %ld.\\n", res);
        __builtin_trap();
    }
}

static void assert_second_unpack(int res)
{
    if (res < 0) {
        printf("Second unpack failed with %ld.\\n", res);
        __builtin_trap();
    }
}

static void assert_second_unpack_data(const void *unpacked_p,
                                      const void *unpacked2_p,
                                      size_t size)
{
    if (memcmp(unpacked_p, unpacked2_p, size) != 0) {
        printf("Second unpacked data does not match first unpacked data.\\n");
        __builtin_trap();
    }
}

static void assert_second_pack(int res, int res2)
{
    if (res != res2) {
        printf("Second pack result %ld does not match first pack "
               "result %ld.\\n",
               res,
               res2);
        __builtin_trap();
    }
}

static void assert_second_pack_data(const uint8_t *packed_p,
                                    const uint8_t *packed2_p,
                                    int size)
{
    int i;

    if (memcmp(packed_p, packed2_p, size) != 0) {
        for (i = 0; i < size; i++) {
            printf("[%04ld]: 0x%02x 0x%02x\\n", i, packed_p[i], packed2_p[i]);
        }

        __builtin_trap();
    }
}


% for message in ctx.messages:
static void test_${message.struct_name}(
    const uint8_t *packed_p,
    size_t size)
{
    int res;
    int res2;
    uint8_t packed[size];
    uint8_t packed2[size];
    struct ${message.struct_name}_t unpacked;
    struct ${message.struct_name}_t unpacked2;

    memset(&unpacked, 0, sizeof(unpacked));

    res = ${message.struct_name}_unpack(
        &unpacked,
        packed_p,
        size);

    if (res >= 0) {
        res = ${message.struct_name}_pack(
            &packed[0],
            &unpacked,
            sizeof(packed));

        assert_first_pack(res);

        memset(&unpacked2, 0, sizeof(unpacked2));

        res2 = ${message.struct_name}_unpack(
            &unpacked2,
            &packed[0],
            res);

        assert_second_unpack(res2);
        assert_second_unpack_data(&unpacked,
                                  &unpacked2,
                                  sizeof(unpacked));

        res2 = ${message.struct_name}_pack(
            &packed2[0],
            &unpacked,
            sizeof(packed2));

        assert_second_pack(res, res2);
        assert_second_pack_data(&packed[0], &packed2[0], res);
    }
}

% endfor
int LLVMFuzzerTestOneInput(const uint8_t *data_p, size_t size)
{
% for message in ctx.messages:
    test_${message.struct_name}(data_p, size);
% endfor

    return (0);
}
'''

FUZZER_MAKEFILE_FMT = '''\
#
# The MIT License (MIT)
#
# Copyright (c) 2018-2019 Erik Moqvist
#
# Permission is hereby granted, free of charge, to any person
# obtaining a copy of this software and associated documentation
# files (the "Software"), to deal in the Software without
# restriction, including without limitation the rights to use, copy,
# modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

#
# This file was generated by cantools version ${ctx.version} ${ctx.date}.
#

CC = clang
EXE = fuzzer
C_SOURCES = ${'\\\\'}
\t${ctx.database_name}.c ${'\\\\'}
\t${ctx.database_name}_fuzzer.c
CFLAGS = ${'\\\\'}
\t-fprofile-instr-generate ${'\\\\'}
\t-fcoverage-mapping ${'\\\\'}
\t-I. ${'\\\\'}
\t-g -fsanitize=address,fuzzer ${'\\\\'}
\t-fsanitize=signed-integer-overflow ${'\\\\'}
\t-fno-sanitize-recover=all
EXECUTION_TIME ?= 5

all:
\t$(CC) $(CFLAGS) $(C_SOURCES) -o $(EXE)
\trm -f $(EXE).profraw
\tLLVM_PROFILE_FILE="$(EXE).profraw" ${'\\\\'}
\t    ./$(EXE) ${'\\\\'}
\t    -max_total_time=$(EXECUTION_TIME)
\tllvm-profdata merge -sparse $(EXE).profraw -o $(EXE).profdata
\tllvm-cov show ./$(EXE) -instr-profile=$(EXE).profdata
\tllvm-cov report ./$(EXE) -instr-profile=$(EXE).profdata

'''


class Signal(object):

    def __init__(self, signal):
        self._signal = signal
        self.snake_name = camel_to_snake_case(self.name)

    def __getattr__(self, name):
        return getattr(self._signal, name)

    @property
    def unit(self):
        return self._signal.unit if self._signal.unit is not None else '-'

    @property
    def type_length(self):
        if self.length <= 8:
            return 8
        elif self.length <= 16:
            return 16
        elif self.length <= 32:
            return 32
        else:
            return 64

    @property
    def type_name(self):
        if self.is_float:
            if self.length == 32:
                type_name = 'float'
            else:
                type_name = 'double'
        else:
            type_name = 'int{}_t'.format(self.type_length)

            if not self.is_signed:
                type_name = 'u' + type_name

        return type_name

    @property
    def type_suffix(self):
        try:
            return {
                'uint8_t': 'u',
                'uint16_t': 'u',
                'uint32_t': 'u',
                'int64_t': 'll',
                'uint64_t': 'ull',
                'float': 'f'
            }[self.type_name]
        except KeyError:
            return ''

    @property
    def conversion_type_suffix(self):
        try:
            return {
                8: 'u',
                16: 'u',
                32: 'u',
                64: 'ull'
            }[self.type_length]
        except KeyError:
            return ''

    @property
    def unique_choices(self):
        """Make duplicated choice names unique by first appending its value
        and then underscores until unique.

        """

        items = {
            value: camel_to_snake_case(name).upper()
            for value, name in self.choices.items()
        }
        names = list(items.values())
        duplicated_names = [
            name
            for name in set(names)
            if names.count(name) > 1
        ]
        unique_choices = {
            value: name
            for value, name in items.items()
            if names.count(name) == 1
        }

        for value, name in items.items():
            if name in duplicated_names:
                name += _canonical('_{}'.format(value))

                while name in unique_choices.values():
                    name += '_'

                unique_choices[value] = name

        return unique_choices

    @property
    def minimum_type_value(self):
        if self.type_name == 'int8_t':
            return -128
        elif self.type_name == 'int16_t':
            return -32768
        elif self.type_name == 'int32_t':
            return -2147483648
        elif self.type_name == 'int64_t':
            return -9223372036854775808
        elif self.type_name[0] == 'u':
            return 0
        else:
            return None

    @property
    def maximum_type_value(self):
        if self.type_name == 'int8_t':
            return 127
        elif self.type_name == 'int16_t':
            return 32767
        elif self.type_name == 'int32_t':
            return 2147483647
        elif self.type_name == 'int64_t':
            return 9223372036854775807
        elif self.type_name == 'uint8_t':
            return 255
        elif self.type_name == 'uint16_t':
            return 65535
        elif self.type_name == 'uint32_t':
            return 4294967295
        elif self.type_name == 'uint64_t':
            return 18446744073709551615
        else:
            return None

    @property
    def minimum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return -(2 ** (self.length - 1))
        else:
            return 0

    @property
    def maximum_value(self):
        if self.is_float:
            return None
        elif self.is_signed:
            return ((2 ** (self.length - 1)) - 1)
        else:
            return ((2 ** self.length) - 1)

    def segments(self, invert_shift):
        index, pos = divmod(self.start, 8)
        left = self.length

        while left > 0:
            if self.byte_order == 'big_endian':
                if left >= (pos + 1):
                    length = (pos + 1)
                    pos = 7
                    shift = -(left - length)
                    mask = ((1 << length) - 1)
                else:
                    length = left
                    shift = (pos - length + 1)
                    mask = ((1 << length) - 1)
                    mask <<= (pos - length + 1)
            else:
                shift = (left - self.length) + pos

                if left >= (8 - pos):
                    length = (8 - pos)
                    mask = ((1 << length) - 1)
                    mask <<= pos
                    pos = 0
                else:
                    length = left
                    mask = ((1 << length) - 1)
                    mask <<= pos

            if invert_shift:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'left'
                else:
                    shift_direction = 'right'
            else:
                if shift < 0:
                    shift = -shift
                    shift_direction = 'right'
                else:
                    shift_direction = 'left'

            yield index, shift, shift_direction, mask

            left -= length
            index += 1

    def range_str(self):
        minimum = self.decimal.minimum
        maximum = self.decimal.maximum
        scale = self.decimal.scale
        offset = self.decimal.offset

        if minimum is not None and maximum is not None:
            return '{}..{} ({}..{} {})'.format(
                _format_decimal((minimum - offset) / scale),
                _format_decimal((maximum - offset) / scale),
                minimum,
                maximum,
                self.unit)
        elif minimum is not None:
            return '{}.. ({}.. {})'.format(
                _format_decimal((minimum - offset) / scale),
                minimum,
                self.unit)
        elif maximum is not None:
            return '..{} (..{} {})'.format(
                _format_decimal((maximum - offset) / scale),
                maximum,
                self.unit)
        else:
            return '-'

    def scale_str(self):
        return self.scale if self.scale is not None else '-'

    def offset_str(self):
        return self.offset if self.offset is not None else '-'


class Message(object):

    def __init__(self, database_name, message):
        self._message = message
        self.struct_name = '{}_{}'.format(database_name,
                                          camel_to_snake_case(message.name))
        self.snake_name = camel_to_snake_case(self.name)
        self.signals = [Signal(signal)for signal in message.signals]

    def __getattr__(self, name):
        return getattr(self._message, name)

    def get_signal_by_name(self, name):
        for signal in self.signals:
            if signal.name == name:
                return signal


class Context(object):

    def __init__(self,
                 database,
                 database_name,
                 floating_point_numbers=True,
                 bit_fields=False):
        self.version = __version__
        self.date = time.ctime()

        self.database_name = database_name

        self.include_guard = '{}_H'.format(database_name.upper())
        self.messages = [Message(database_name, message)
                         for message in database.messages]

        self.bit_fields = bit_fields
        self.floating_point_numbers = floating_point_numbers

    @staticmethod
    def indent_c_comment(comment, indent_spaces=0):
        if comment:
            return '\n'.join([
                '{} * '.format(' '*indent_spaces) + line.rstrip()
                for line in comment.splitlines()
            ])
        else:
            return ''


def _canonical(value):
    """Replace anything but 'a-z', 'A-Z' and '0-9' with '_'.

    """

    return re.sub(r'[^a-zA-Z0-9]', '_', value)


def camel_to_snake_case(value):
    value = re.sub(r'(.)([A-Z][a-z]+)', r'\1_\2', value)
    value = re.sub(r'(_+)', '_', value)
    value = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', value).lower()
    value = _canonical(value)

    return value


def _format_decimal(value):
    if int(value) == value:
        return str(int(value))
    return str(value)
