/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version ${ctx.version} ${ctx.date}.
 */

#include <string.h>

#include "${ctx.output_basename}.h"

<%def name="emit_signal_helper(message, signal_name)">\
<%
signal = message.get_signal_by_name(signal_name)
%>\
% for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
% if (signal.type_length, shift_direction) not in seen_packer_helpers:
static inline uint8_t pack_${shift_direction}_shift_u${signal.type_length}(
    uint${signal.type_length}_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value ${'<<' if shift_direction=='left' else '>>'} shift) & mask);
}

<%
seen_packer_helpers.add((signal.type_length, shift_direction))
%>\
% endif
% endfor
% for index, shift, shift_direction, mask in signal.segments(invert_shift=True):
% if (signal.type_length, shift_direction) not in seen_unpacker_helpers:
static inline uint${signal.type_length}_t unpack_${shift_direction}_shift_u${signal.type_length}(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint${signal.type_length}_t)((uint${signal.type_length}_t)(value & mask) ${'<<' if shift_direction=='left' else '>>'} shift);
}

<%
seen_unpacker_helpers.add((signal.type_length, shift_direction))
%>\
% endif
% endfor
</%def>\
<%def name="emit_signal_helpers(message, signal_names)">\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
%>\
${emit_signal_helper(message, signal_name)}\
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
${emit_signal_helpers(message, multiplexed_signals)}\
% endfor
% else: # if isinstance(signal_name, dict):
${emit_signal_helper(message, signal_name)}\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\
<%
seen_packer_helpers = set()
seen_unpacker_helpers = set()
%>\
% for message in ctx.messages:
${emit_signal_helpers(message, message.signal_tree)}\
% endfor
<%def name="emit_signal_pack_variables(seen_vars, message, signal_name)">\
<%
signal = message.get_signal_by_name(signal_name)
%>\
% if signal.is_float or signal.is_signed:
% if (signal.type_length, signal.snake_name) not in seen_vars:
    uint${signal.type_length}_t ${signal.snake_name};
<%
seen_vars.add((signal.type_length, signal.snake_name))
%>\
% endif # if (${signal.type_length}, ${signal.snake_name}) not in seen_vars:
% endif # if signal.is_float or signal.is_signed:
</%def>\
<%def name="emit_message_pack_variables(seen_vars, message, signal_names)">\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
%>\
${emit_signal_pack_variables(seen_vars, message, signal_name)}\
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:
${emit_message_pack_variables(seen_vars, message, multiplexed_signals)}\
% endfor
% else: # if isinstance(signal_name, dict):
${emit_signal_pack_variables(seen_vars, message, signal_name)}\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\
<%def name="emit_signal_pack_body(message, signal_name, indent_level)">\
<%
signal = message.get_signal_by_name(signal_name)
%>\
% if signal.is_float:
${'    ' * indent_level}memcpy(&${signal.snake_name}, &src_p->${signal.snake_name}, sizeof(${signal.snake_name}));
% elif signal.is_signed:
${'    ' * indent_level}${signal.snake_name} = (uint${signal.type_length}_t)src_p->${signal.snake_name};
% endif # if signal.is_float:
% for index, shift, shift_direction, mask in signal.segments(invert_shift=False):
% if signal.is_float or signal.is_signed:
${'    ' * indent_level}dst_p[${index}] |= pack_${shift_direction}_shift_u${signal.type_length}(${signal.snake_name}, ${shift}u, ${"0x%02x" % mask}u);
% else: # if signal.is_float or signal.is_signed:
${'    ' * indent_level}dst_p[${index}] |= pack_${shift_direction}_shift_u${signal.type_length}(src_p->${signal.snake_name}, ${shift}u, ${"0x%02x" % mask}u);
% endif # if signal.is_float or signal.is_signed:
% endfor
</%def>\
<%def name="emit_message_pack_body(message, signal_names, indent_level=1)">\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
signal = message.get_signal_by_name(signal_name)
%>\
${emit_signal_pack_body(message, signal_name, indent_level)}\

${'    ' * indent_level}switch (src_p->${signal.snake_name}) {
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:

${'    ' * indent_level}case ${multiplexer_id}:
${emit_message_pack_body(message, multiplexed_signals, indent_level+1)}\
${'    ' * (indent_level+1)}break;
% endfor

${'    ' * indent_level}default:
${'    ' * (indent_level+1)}break;
${'    ' * indent_level}}
% else: # if isinstance(signal_name, dict):
${emit_signal_pack_body(message, signal_name, indent_level)}\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\
<%def name="emit_signal_unpack_body(message, signal_name, indent_level)">\
<%
signal = message.get_signal_by_name(signal_name)
%>\
% for i, (index, shift, shift_direction, mask) in enumerate(signal.segments(invert_shift=True)):
% if signal.is_float or signal.is_signed:
${'    ' * indent_level}${signal.snake_name} ${'=' if i==0 else '|='} unpack_${shift_direction}_shift_u${signal.type_length}(src_p[${index}], ${shift}u, ${"0x%02x" % mask}u);
% else:
${'    ' * indent_level}dst_p->${signal.snake_name} ${'=' if i==0 else '|='} unpack_${shift_direction}_shift_u${signal.type_length}(src_p[${index}], ${shift}u, ${"0x%02x" % mask}u);
% endif # signal.is_float or signal.is_signed:
% endfor
% if signal.is_float:
${'    ' * indent_level}memcpy(&dst_p->${signal.snake_name}, &${signal.snake_name}, sizeof(dst_p->${signal.snake_name}));
% elif signal.is_signed:
<%
mask = ((1 << (signal.type_length - signal.length)) - 1)
%>\
% if mask != 0:

${'    ' * indent_level}if ((${signal.snake_name} & (1${signal.conversion_type_suffix} << ${signal.length - 1})) != 0${signal.conversion_type_suffix}) {
${'    ' * indent_level}    ${signal.snake_name} |= ${"0x%x" % (mask << signal.length)}${signal.conversion_type_suffix};
${'    ' * indent_level}}

% endif # mask != 0:
${'    ' * indent_level}dst_p->${signal.snake_name} = (int${signal.type_length}_t)${signal.snake_name};
% endif # signal.is_float:
</%def>\
<%def name="emit_message_unpack_body(message, signal_names, indent_level=1)">\
% for signal_name in signal_names:
% if isinstance(signal_name, dict):
<%
signal_name, multiplexed_signals = list(signal_name.items())[0]
multiplexed_signals_per_id = sorted(list(multiplexed_signals.items()))
signal = message.get_signal_by_name(signal_name)
%>\
${emit_signal_unpack_body(message, signal_name, indent_level)}\

${'    ' * indent_level}switch (dst_p->${signal.snake_name}) {
% for multiplexer_id, multiplexed_signals in multiplexed_signals_per_id:

${'    ' * indent_level}case ${multiplexer_id}:
${emit_message_unpack_body(message, multiplexed_signals, indent_level+1)}\
${'    ' * (indent_level+1)}break;
% endfor

${'    ' * indent_level}default:
${'    ' * (indent_level+1)}break;
${'    ' * indent_level}}
% else: # if isinstance(signal_name, dict):
${emit_signal_unpack_body(message, signal_name, indent_level)}\
% endif # if isinstance(signal_name, dict):
% endfor
</%def>\
% for message in ctx.messages:
% if message.length > 0:
int ${message.struct_name}_pack(
    uint8_t *dst_p,
    const struct ${message.struct_name}_t *src_p,
    size_t size)
{
% if len(message.signals) == 0:
    (void)src_p;
% endif # if len(message.signals) == 0:
${emit_message_pack_variables(set(), message, message.signal_tree)}\

    if (size < ${message.length}u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, ${message.length});

${emit_message_pack_body(message, message.signal_tree)}\

    return (${message.length});
}

int ${message.struct_name}_unpack(
    struct ${message.struct_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
% if len(message.signals) == 0:
    (void)src_p;
% endif # if len(message.signals) == 0:
<%
seen_vars = set()
%>\
${emit_message_pack_variables(seen_vars, message, message.signal_tree)}\

    if (size < ${message.length}u) {
        return (-EINVAL);
    }

${emit_message_unpack_body(message, message.signal_tree)}\

    return (0);
}
% else: # if message.length > 0:
int ${message.struct_name}_pack(
    uint8_t *dst_p,
    const struct ${message.struct_name}_t *src_p,
    size_t size)
{
    (void)dst_p;
    (void)src_p;
    (void)size;

    return (0);
}

int ${message.struct_name}_unpack(
    struct ${message.struct_name}_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;
    (void)size;

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}
% endif # if message.length > 0:

% for signal in message.signals:
<%
scale = signal.decimal.scale
offset = signal.decimal.offset
if offset == 0 and scale == 1:
    encoding = 'value'
    decoding = '(double)value'
elif offset != 0 and scale != 1:
    encoding = '(value - {}) / {}'.format(float(offset),
                                          float(scale))
    decoding = '((double)value * {}) + {}'.format(float(scale),
                                                  float(offset))
elif offset != 0:
    encoding = 'value - {}'.format(float(offset))
    decoding = '(double)value + {}'.format(float(offset))
else:
    encoding = 'value / {}'.format(float(scale))
    decoding = '(double)value * {}'.format(float(scale))
%>\
% if ctx.floating_point_numbers:
${signal.type_name} ${message.struct_name}_${signal.snake_name}_encode(double value)
{
    return (${signal.type_name})(${encoding});
}

double ${message.struct_name}_${signal.snake_name}_decode(${signal.type_name} value)
{
    return (${decoding});
}

% endif # if ctx.floating_point_numbers:
bool ${message.struct_name}_${signal.snake_name}_is_in_range(${signal.type_name} value)
{
<%
scale = signal.decimal.scale
offset = (signal.decimal.offset / scale)
minimum = signal.decimal.minimum
maximum = signal.decimal.maximum

if minimum is not None:
    minimum = (minimum / scale - offset)

if maximum is not None:
    maximum = (maximum / scale - offset)

if minimum is None and signal.minimum_value is not None:
    if signal.minimum_value > signal.minimum_type_value:
        minimum = signal.minimum_value

if maximum is None and signal.maximum_value is not None:
    if signal.maximum_value < signal.maximum_type_value:
        maximum = signal.maximum_value

check = []

if minimum is not None:
    if (signal.minimum_type_value is None) or (minimum > signal.minimum_type_value):
        minimum = float(minimum) if signal.is_float else int(minimum)
        check.append('value >= {}{}'.format(minimum, signal.type_suffix))

if maximum is not None:
    if (signal.maximum_type_value is None) or (maximum < signal.maximum_type_value):
        maximum = float(maximum) if signal.is_float else int(maximum)
        check.append('value <= {}{}'.format(maximum, signal.type_suffix))
%>\
% if len(check) == 0:
    (void)value;

    return (true);
% elif len(check) == 1:
    return (${check[0]});
% else:
    return (${' && '.join(['({})'.format(c) for c in check])});
% endif
}

% endfor
% endfor
